<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>STAGE 3D — Debug</title>
  <style>
    body { margin:0; background:#000; color:#0f0; font-family: Arial, sans-serif; }
    #title { position:absolute; top:10px; width:100%; text-align:center; font-size:22px; text-shadow:0 0 8px #0f0; z-index:10; }
    #instructions { position:absolute; bottom:10px; width:100%; text-align:center; font-size:13px; z-index:10; }
    #log { position: absolute; left:10px; top:60px; max-width: calc(100% - 20px); color:#f88; font-size:13px; background: rgba(0,0,0,0.6); padding:8px; border-radius:6px; z-index:11; }
    canvas { display:block; }
    a.debug { color: #0ff; text-decoration: underline; }
  </style>
</head>
<body>
  <div id="title">STAGE 3D</div>
  <div id="instructions">Toque/arraste • pinça para zoom • dois dedos para mover</div>
  <div id="log" style="display:none"></div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/loaders/GLTFLoader.js"></script>

  <script>
    // ---------- CONFIG ----------
    const RAW_URL = "https://raw.githubusercontent.com/VJ-RIBA/3D./main/model.glb";
    // ---------- /CONFIG ----------

    const logEl = document.getElementById('log');
    function log(msg, isError = false) {
      console[isError ? 'error' : 'log']('[STAGE3D] ' + msg);
      logEl.style.display = 'block';
      logEl.innerText = (logEl.innerText ? logEl.innerText + "\n" : "") + msg;
    }

    // Setup cena
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.05, 2000);
    camera.position.set(3,2,5);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const dir = new THREE.DirectionalLight(0xffffff, 1.0);
    dir.position.set(6,10,8);
    scene.add(dir);

    // array de objetos "moving"
    const movingObjects = [];

    // GLTF loader pra parse (usado após fetch do ArrayBuffer)
    const loader = new THREE.GLTFLoader();

    // Carregar via fetch -> arrayBuffer -> parse (mais tolerante)
    async function loadGLB(url) {
      try {
        log('Tentando baixar: ' + url);
        const resp = await fetch(url);
        if (!resp.ok) {
          throw new Error('Resposta HTTP não OK: ' + resp.status + ' ' + resp.statusText);
        }
        // opcional: conferir content-type
        const ct = resp.headers.get('content-type') || '';
        log('Content-Type: ' + ct);
        const buffer = await resp.arrayBuffer();
        log('Arquivo baixado (' + Math.round(buffer.byteLength/1024) + ' KB), iniciando parse...');
        loader.parse(buffer, '', (gltf) => {
          log('Parse concluído — adicionando cena');
          const model = gltf.scene || gltf.scenes[0];
          scene.add(model);

          model.traverse((obj) => {
            if (obj.isMesh) {
              // suporta material array ou único
              const applyToMaterial = (mat) => {
                if (!mat) return;
                // clone para não alterar material original de outros meshes
                try {
                  const cloned = mat.clone();
                  // guarda como propriedade para a animação
                  cloned.userData = cloned.userData || {};
                  return cloned;
                } catch (e) {
                  return mat;
                }
              };

              if (Array.isArray(obj.material)) {
                const arr = obj.material.map(m => applyToMaterial(m) || m);
                obj.material = arr;
              } else {
                obj.material = applyToMaterial(obj.material) || obj.material;
              }

              // se o nome contem "moving" => registra para piscar + girar
              if (obj.name && obj.name.toLowerCase().includes('moving')) {
                // garante emissive disponível
                if (Array.isArray(obj.material)) {
                  obj.material.forEach(m => { if (m) { m.emissive = new THREE.Color(0x00ff00); m.emissiveIntensity = 1; }});
                } else {
                  obj.material.emissive = new THREE.Color(0x00ff00);
                  obj.material.emissiveIntensity = 1;
                }
                movingObjects.push(obj);
                log('Registrado moving: ' + obj.name);
              }
            }
          });

        }, (err) => {
          throw err;
        });

      } catch (err) {
        log('Erro ao carregar/parsing do GLB: ' + (err && err.message ? err.message : err), true);
        // fallback: mostrar link raw para abrir direto
        const a = document.createElement('a');
        a.href = url;
        a.target = '_blank';
        a.className = 'debug';
        a.innerText = '\nAbrir arquivo RAW diretamente';
        logEl.appendChild(document.createElement('br'));
        logEl.appendChild(a);
      }
    }

    // inicia o carregamento
    loadGLB(RAW_URL);

    // animação
    const clock = new THREE.Clock();
    function animate() {
      requestAnimationFrame(animate);
      const t = clock.getElapsedTime();

      // anima moving: pulsar emissiveIntensity e girar
      movingObjects.forEach((obj, idx) => {
        // calcula pulso (varia por objeto para parecer orgânico)
        const speed = 3 + idx * 0.3;
        const pulse = (Math.sin(t * speed) + 1) / 2; // 0..1
        if (Array.isArray(obj.material)) {
          obj.material.forEach(m => { if (m) m.emissiveIntensity = 0.6 + pulse * 3.0; });
        } else {
          obj.material.emissiveIntensity = 0.6 + pulse * 3.0;
        }
        // giro
        obj.rotation.y += 0.01 + (idx * 0.002);
      });

      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // instrução extra para debug: abra console do navegador (F12 ou DevTools)
    log('Iniciado. Se algo falhar, abra o console do navegador (F12 / DevTools) para ver erros completos.');
  </script>
</body>
</html>
