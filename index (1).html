<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>STAGE 3D — Debug</title>
  <style>
    body { margin:0; background:#000; color:#0f0; font-family: Arial, sans-serif; }
    #title { position:absolute; top:10px; width:100%; text-align:center; font-size:22px; text-shadow:0 0 8px #0f0; z-index:10; }
    #instructions { position:absolute; bottom:10px; width:100%; text-align:center; font-size:13px; z-index:10; }
    #log { position: absolute; left:10px; top:60px; max-width: calc(100% - 20px); color:#f88; font-size:13px; background: rgba(0,0,0,0.6); padding:8px; border-radius:6px; z-index:11; }
    canvas { display:block; }
    a.debug { color: #0ff; text-decoration: underline; }
  </style>
</head>
<body>
  <div id="title">STAGE 3D</div>
  <div id="instructions">Toque/arraste • pinça para zoom • dois dedos para mover</div>
  <div id="log" style="display:none"></div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/loaders/GLTFLoader.js"></script>

  <script>
    const RAW_URL = "https://raw.githubusercontent.com/VJ-RIBA/3D./main/model.glb";
    const logEl = document.getElementById('log');
    function log(msg, isError = false) {
      console[isError ? 'error' : 'log']('[STAGE3D] ' + msg);
      logEl.style.display = 'block';
      logEl.innerText = (logEl.innerText ? logEl.innerText + "\n" : "") + msg;
    }

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.05, 2000);
    camera.position.set(3,2,5);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const dir = new THREE.DirectionalLight(0xffffff, 1.0);
    dir.position.set(6,10,8);
    scene.add(dir);

    const movingObjects = [];
    const loader = new THREE.GLTFLoader();

    async function loadGLB(url) {
      try {
        log('Tentando baixar: ' + url);
        const resp = await fetch(url);
        if (!resp.ok) {
          throw new Error('Resposta HTTP não OK: ' + resp.status + ' ' + resp.statusText);
        }
        const ct = resp.headers.get('content-type') || '';
        log('Content-Type: ' + ct);
        const buffer = await resp.arrayBuffer();
        log('Arquivo baixado (' + Math.round(buffer.byteLength/1024) + ' KB), iniciando parse...');
        loader.parse(buffer, '', (gltf) => {
          log('Parse concluído — adicionando cena');
          const model = gltf.scene || gltf.scenes[0];
          scene.add(model);

          model.traverse((obj) => {
            if (obj.isMesh) {
              const applyToMaterial = (mat) => {
                if (!mat) return;
                try {
                  const cloned = mat.clone();
                  cloned.userData = cloned.userData || {};
                  return cloned;
                } catch (e) { return mat; }
              };

              if (Array.isArray(obj.material)) {
                obj.material = obj.material.map(m => applyToMaterial(m) || m);
              } else {
                obj.material = applyToMaterial(obj.material) || obj.material;
              }

              if (obj.name && obj.name.toLowerCase().includes('moving')) {
                if (Array.isArray(obj.material)) {
                  obj.material.forEach(m => { if (m) { m.emissive = new THREE.Color(0x00ff00); m.emissiveIntensity = 1; }});
                } else {
                  obj.material.emissive = new THREE.Color(0x00ff00);
                  obj.material.emissiveIntensity = 1;
                }
                movingObjects.push(obj);
                log('Registrado moving: ' + obj.name);
              }
            }
          });

        }, (err) => { throw err; });

      } catch (err) {
        log('Erro ao carregar/parsing do GLB: ' + (err && err.message ? err.message : err), true);
        const a = document.createElement('a');
        a.href = url;
        a.target = '_blank';
        a.className = 'debug';
        a.innerText = '\nAbrir arquivo RAW diretamente';
        logEl.appendChild(document.createElement('br'));
        logEl.appendChild(a);
      }
    }

    loadGLB(RAW_URL);

    const clock = new THREE.Clock();
    function animate() {
      requestAnimationFrame(animate);
      const t = clock.getElapsedTime();

      movingObjects.forEach((obj, idx) => {
        const speed = 3 + idx * 0.3;
        const pulse = (Math.sin(t * speed) + 1) / 2;
        if (Array.isArray(obj.material)) {
          obj.material.forEach(m => { if (m) m.emissiveIntensity = 0.6 + pulse * 3.0; });
        } else {
          obj.material.emissiveIntensity = 0.6 + pulse * 3.0;
        }
        obj.rotation.y += 0.01 + (idx * 0.002);
      });

      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    log('Iniciado. Se algo falhar, abra o console do navegador.');
  </script>
</body>
</html>
